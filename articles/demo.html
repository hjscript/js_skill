<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>demo</title>
</head>

<body>
</body>
<script>
// //1 
// function toThousands(num){
// 	var str=num.toString();
// 	//写for循环习惯一把长度保存下来这样不用每次去获取(数组去重除外)
// 	var len=str.length;
// 	var res=[];
// 	var i=len;
// 	str=str.split("").join('');
// 	while(i>=3){ //必要条件
// 		res.unshift(str.slice(i-3,i));
// 		i-=3;
// 	}
// 	if(!(i%3==0)&&i!=0){
// 		console.log(i)
// 		res.unshift(str.slice(0,i));
// 	}
// 	return res.join(',');
// }
// toThousands(1234567890)

//2
// function toThousands(num){
// 	var str=num.toString().split('');
// 	//写for循环习惯一把长度保存下来这样不用每次去获取(数组去重除外)
// 	var len=str.length;
// 	var res=[],count=0;
// 	for(var i=len;i>0;i--){
// 		res.unshift(str.pop());  
// 		count++;
// 		console.log(count,len);
// 		if(count%3==0&&count!=len){
// 			res.unshift(',');
// 		}
// 	}
// 	console.log(res.join(''))
// 	return res.join('');
// }
// toThousands(1234567); toThousands(123456);

//3
// function toThousands(num){
// 	var str=num.toString().split('');
// 	//写for循环习惯一把长度保存下来这样不用每次去获取(数组去重除外)
// 	var len=str.length;
// 	var res=[],count=0;
// 	for(var i=len;i>0;i--){
// 		res.unshift(str.pop());  
// 		count++;
// 		console.log(count,len);
// 		if(!(count%3==0)&&count!=len){
// 			res.unshift(',');
// 		}
// 	}
// 	console.log(res.join(''))
// 	return res.join('');
// }

//4
// function toThousands(num){
// 	var str=num.toString();
//  	//写for循环习惯一把长度保存下来这样不用每次去获取(数组去重除外)
//  	var len=str.length;
//  	var res="",count=0;
//  	for (var i=len-1;i>=0;i--) {
//  		count++;
//  		res=str.charAt(i)+res;
//  		console.log(len,i);
//  		if(!(count%3)&&i!=0){
//  			res=','+res;
//  		}
//  	}
//  	console.log(res);
//  	return res;
// }

// toThousands(123456)

//JS查找字符串中出现次数最多的字符
//1用charAt
// function mostCharInStr(paramStr) {
// 	var str = paramStr,
// 		len=str.length,
// 		obj={},
// 		cur='',
// 		max=0,
// 		s='';
// 	for (var i = 0; i < len; i++) {
// 		 cur=str.charAt(i);
// 		if(!obj[cur]){  //这里不能是0而是1坑
// 			obj[cur]=1;
// 		}
// 		else{
// 			obj[cur]+=1;
// 		}
// 	}
// 	for(var key in obj){
// 		if(obj[key]>max){
// 			max=obj[key]
// 			s=key;
// 		}
// 	}
// 	return [s,max];
// }
// mostCharInStr(paramStr)

//2 用indexOf
// function mostCharInStr(paramStr) {
// 	var str=paramStr,
// 		len=str.length-1,
// 		arr=[],
// 		cur='',
// 		max=0,
// 		index=0;
// 		while(len>0){
// 			index=str.indexOf(str[len],index+1);
// 			len--;
// 		}
// }
// mostCharInStr('31232131323423434');


// 节流
// 定义:
//当持续触发事件时，在规定时间段内只能调用一次回调函数。如果在规定时间内又触发了该事件，则什么也不做,也不会重置定时器.(套公式)
let now = null
function jieliu(fn, await) {
 now = new Date()  
    let remain = now 5 - await 2
    setTimeout(function() {
        if (remain 3 >= await 2) {
            fn()
        }
    }, await)
}


// 防抖 
// 指触发事件后在规定时间内回调函数只能执行一次，如果在规定时间内又触发了该事件，则会重新开始算规定时间。

//网上有这个比喻:函数防抖就是法师发技能的时候要读条，技能读条没完再按技能就会刷新技能,重新进行读条。

//四个字总结就是 延时执行
let now = null,timer = null
function fangdou(fn, await) {
    now = new Date()  
    let remain = now 5 - await 2
    timer = setTimeout(function() {
        if(!timer) {
            fn()
        } else{
        	await = remain
        	fn()
        }
    }, await)
}
</script>
</body>

</html>